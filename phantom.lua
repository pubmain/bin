-- Copyright pubmain 2025
-- github.com/pubmain
-- By exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this Creative Commons Attribution-NonCommercial 4.0 International Public License ("Public License"). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions.

-- Section 1 Definitions.

-- a. Adapted Material means material subject to Copyright and Similar Rights that is derived from or based upon the Licensed Material and in which the Licensed Material is translated, altered, arranged, transformed, or otherwise modified in a manner requiring permission under the Copyright and Similar Rights held by the Licensor. For purposes of this Public License, where the Licensed Material is a musical work, performance, or sound recording, Adapted Material is always produced where the Licensed Material is synched in timed relation with a moving image.
-- b. Adapter's License means the license You apply to Your Copyright and Similar Rights in Your contributions to Adapted Material in accordance with the terms and conditions of this Public License.
-- c. Copyright and Similar Rights means copyright and/or similar rights closely related to copyright including, without limitation, performance, broadcast, sound recording, and Sui Generis Database Rights, without regard to how the rights are labeled or categorized. For purposes of this Public License, the rights specified in Section 2(b)(1)-(2) are not Copyright and Similar Rights.
-- d. Effective Technological Measures means those measures that, in the absence of proper authority, may not be circumvented under laws fulfilling obligations under Article 11 of the WIPO Copyright Treaty adopted on December 20, 1996, and/or similar international agreements.
-- e. Exceptions and Limitations means fair use, fair dealing, and/or any other exception or limitation to Copyright and Similar Rights that applies to Your use of the Licensed Material.
-- f. Licensed Material means the artistic or literary work, database, or other material to which the Licensor applied this Public License.
-- g. Licensed Rights means the rights granted to You subject to the terms and conditions of this Public License, which are limited to all Copyright and Similar Rights that apply to Your use of the Licensed Material and that the Licensor has authority to license.
-- h. Licensor means the individual(s) or entity(ies) granting rights under this Public License.
-- i. NonCommercial means not primarily intended for or directed towards commercial advantage or monetary compensation. For purposes of this Public License, the exchange of the Licensed Material for other material subject to Copyright and Similar Rights by digital file-sharing or similar means is NonCommercial provided there is no payment of monetary compensation in connection with the exchange.
-- j. Share means to provide material to the public by any means or process that requires permission under the Licensed Rights, such as reproduction, public display, public performance, distribution, dissemination, communication, or importation, and to make material available to the public including in ways that members of the public may access the material from a place and at a time individually chosen by them.
-- k. Sui Generis Database Rights means rights other than copyright resulting from Directive 96/9/EC of the European Parliament and of the Council of 11 March 1996 on the legal protection of databases, as amended and/or succeeded, as well as other essentially equivalent rights anywhere in the world.
-- l. You means the individual or entity exercising the Licensed Rights under this Public License. Your has a corresponding meaning.
-- Section 2 Scope.

-- a. License grant.
-- 1. Subject to the terms and conditions of this Public License, the Licensor hereby grants You a worldwide, royalty-free, non-sublicensable, non-exclusive, irrevocable license to exercise the Licensed Rights in the Licensed Material to:
-- A. reproduce and Share the Licensed Material, in whole or in part, for NonCommercial purposes only; and
-- B. produce, reproduce, and Share Adapted Material for NonCommercial purposes only.
-- 2. Exceptions and Limitations. For the avoidance of doubt, where Exceptions and Limitations apply to Your use, this Public License does not apply, and You do not need to comply with its terms and conditions.
-- 3. Term. The term of this Public License is specified in Section 6(a).
-- 4. Media and formats; technical modifications allowed. The Licensor authorizes You to exercise the Licensed Rights in all media and formats whether now known or hereafter created, and to make technical modifications necessary to do so. The Licensor waives and/or agrees not to assert any right or authority to forbid You from making technical modifications necessary to exercise the Licensed Rights, including technical modifications necessary to circumvent Effective Technological Measures. For purposes of this Public License, simply making modifications authorized by this Section 2(a)(4) never produces Adapted Material.
-- 5. Downstream recipients.
-- A. Offer from the Licensor â€“ Licensed Material. Every recipient of the Licensed Material automatically receives an offer from the Licensor to exercise the Licensed Rights under the terms and conditions of this Public License.
-- B. No downstream restrictions. You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, the Licensed Material if doing so restricts exercise of the Licensed Rights by any recipient of the Licensed Material.
-- 6. No endorsement. Nothing in this Public License constitutes or may be construed as permission to assert or imply that You are, or that Your use of the Licensed Material is, connected with, or sponsored, endorsed, or granted official status by, the Licensor or others designated to receive attribution as provided in Section 3(a)(1)(A)(i).
-- b. Other rights.
-- 1. Moral rights, such as the right of integrity, are not licensed under this Public License, nor are publicity, privacy, and/or other similar personality rights; however, to the extent possible, the Licensor waives and/or agrees not to assert any such rights held by the Licensor to the limited extent necessary to allow You to exercise the Licensed Rights, but not otherwise.
-- 2. Patent and trademark rights are not licensed under this Public License.
-- 3. To the extent possible, the Licensor waives any right to collect royalties from You for the exercise of the Licensed Rights, whether directly or through a collecting society under any voluntary or waivable statutory or compulsory licensing scheme. In all other cases the Licensor expressly reserves any right to collect such royalties, including when the Licensed Material is used other than for NonCommercial purposes.
-- Section 3 License Conditions.

-- Your exercise of the Licensed Rights is expressly made subject to the following conditions.

-- a. Attribution.
-- 1. If You Share the Licensed Material (including in modified form), You must:
-- A. retain the following if it is supplied by the Licensor with the Licensed Material:
-- i. identification of the creator(s) of the Licensed Material and any others designated to receive attribution, in any reasonable manner requested by the Licensor (including by pseudonym if designated);
-- ii. a copyright notice;
-- iii. a notice that refers to this Public License;
-- iv. a notice that refers to the disclaimer of warranties;
-- v. a URI or hyperlink to the Licensed Material to the extent reasonably practicable;
-- B. indicate if You modified the Licensed Material and retain an indication of any previous modifications; and
-- C. indicate the Licensed Material is licensed under this Public License, and include the text of, or the URI or hyperlink to, this Public License.
-- 2. You may satisfy the conditions in Section 3(a)(1) in any reasonable manner based on the medium, means, and context in which You Share the Licensed Material. For example, it may be reasonable to satisfy the conditions by providing a URI or hyperlink to a resource that includes the required information.
-- 3. If requested by the Licensor, You must remove any of the information required by Section 3(a)(1)(A) to the extent reasonably practicable.
-- 4. If You Share Adapted Material You produce, the Adapter's License You apply must not prevent recipients of the Adapted Material from complying with this Public License.
-- Section 4 Sui Generis Database Rights.

-- Where the Licensed Rights include Sui Generis Database Rights that apply to Your use of the Licensed Material:

-- a. for the avoidance of doubt, Section 2(a)(1) grants You the right to extract, reuse, reproduce, and Share all or a substantial portion of the contents of the database for NonCommercial purposes only;
-- b. if You include all or a substantial portion of the database contents in a database in which You have Sui Generis Database Rights, then the database in which You have Sui Generis Database Rights (but not its individual contents) is Adapted Material; and
-- c. You must comply with the conditions in Section 3(a) if You Share all or a substantial portion of the contents of the database.
-- For the avoidance of doubt, this Section 4 supplements and does not replace Your obligations under this Public License where the Licensed Rights include other Copyright and Similar Rights.

-- Section 5 Disclaimer of Warranties and Limitation of Liability.

-- a. Unless otherwise separately undertaken by the Licensor, to the extent possible, the Licensor offers the Licensed Material as-is and as-available, and makes no representations or warranties of any kind concerning the Licensed Material, whether express, implied, statutory, or other. This includes, without limitation, warranties of title, merchantability, fitness for a particular purpose, non-infringement, absence of latent or other defects, accuracy, or the presence or absence of errors, whether or not known or discoverable. Where disclaimers of warranties are not allowed in full or in part, this disclaimer may not apply to You.
-- b. To the extent possible, in no event will the Licensor be liable to You on any legal theory (including, without limitation, negligence) or otherwise for any direct, special, indirect, incidental, consequential, punitive, exemplary, or other losses, costs, expenses, or damages arising out of this Public License or use of the Licensed Material, even if the Licensor has been advised of the possibility of such losses, costs, expenses, or damages. Where a limitation of liability is not allowed in full or in part, this limitation may not apply to You.
-- c. The disclaimer of warranties and limitation of liability provided above shall be interpreted in a manner that, to the extent possible, most closely approximates an absolute disclaimer and waiver of all liability.
-- Section 6 Term and Termination.

-- a. This Public License applies for the term of the Copyright and Similar Rights licensed here. However, if You fail to comply with this Public License, then Your rights under this Public License terminate automatically.
-- b. Where Your right to use the Licensed Material has terminated under Section 6(a), it reinstates:
-- 1. automatically as of the date the violation is cured, provided it is cured within 30 days of Your discovery of the violation; or
-- 2. upon express reinstatement by the Licensor.
-- For the avoidance of doubt, this Section 6(b) does not affect any right the Licensor may have to seek remedies for Your violations of this Public License.

-- c. For the avoidance of doubt, the Licensor may also offer the Licensed Material under separate terms or conditions or stop distributing the Licensed Material at any time; however, doing so will not terminate this Public License.
-- d. Sections 1, 5, 6, 7, and 8 survive termination of this Public License.
-- Section 7 Other Terms and Conditions.

-- a. The Licensor shall not be bound by any additional or different terms or conditions communicated by You unless expressly agreed.
-- b. Any arrangements, understandings, or agreements regarding the Licensed Material not stated herein are separate from and independent of the terms and conditions of this Public License.
-- Section 8 Interpretation.

-- a. For the avoidance of doubt, this Public License does not, and shall not be interpreted to, reduce, limit, restrict, or impose conditions on any use of the Licensed Material that could lawfully be made without permission under this Public License.
-- b. To the extent possible, if any provision of this Public License is deemed unenforceable, it shall be automatically reformed to the minimum extent necessary to make it enforceable. If the provision cannot be reformed, it shall be severed from this Public License without affecting the enforceability of the remaining terms and conditions.
-- c. No term or condition of this Public License will be waived and no failure to comply consented to unless expressly agreed to by the Licensor.
-- d. Nothing in this Public License constitutes or may be interpreted as a limitation upon, or waiver of, any privileges and immunities that apply to the Licensor or You, including from the legal processes of any jurisdiction or authority.

_G.PTM_MODES = _G.PTM_MODES or { NoAssets = true, NoActorHooking = true }
local PHANTOM_ENV = getfenv()
PHANTOM_ENV.SCRIPT_VERSION = "0.1.1"
setfenv(0, PHANTOM_ENV)

do
	local ADONIS_BYPASSED = false
	for _, mod in getloadedmodules() do
		if mod.Name == "Anti" and not ADONIS_BYPASSED then
			loadstring(
				game:HttpGet("https://raw.githubusercontent.com/Pixeluted/adoniscries/refs/heads/main/Source.lua")
			)()
			ADONIS_BYPASSED = true
		end
	end
end

local function SendNotification(data)
	game:GetService("StarterGui"):SetCore("SendNotification", data)
end

do
	local REQUIRED_FUNCTIONS = {
		"gethui",
		"cloneref",
		"hookfunction",
		"iscclosure",
		"getconnections",
		"getgenv",
		"mouse1press",
	}
	gethui = gethui or get_hidden_gui
	hookfunction = hookfunction or replaceclosure
	-- if not mouse1click then
	-- 	mouse1click = newcclosure(function()
	-- 		keypress(0x01)
	-- 	end)
	-- end
	-- if not mouse1release then
	-- 	mouse1release = newcclosure(function()
	-- 		keyrelease(0x01)
	-- 	end)
	-- end
	if not iscclosure then
		return SendNotification({ Title = "Executor not supported", Text = "Couldnt find iscclosure" })
	end
	local env = getfenv()
	for _, name in REQUIRED_FUNCTIONS do
		local func = env[name]
		if not func then
			return SendNotification({ Title = "Executor not supported", Text = "Couldnt find function " .. name })
		end
		if not iscclosure(func) then
			return SendNotification({
				Title = "Executor not supported",
				Text = "Function " .. name .. " is not a c closure!",
			})
		end
	end
end

local AssetMap = {
	SettingsButton = "rbxassetid://1204397029",
}

--[[ MODES
noassets - safest mode, cant be detected by any ContentProvider check
]]
local PhantomModes = _G.PTM_MODES
	or {
		NoAssets = _G.PTM_MODE == "noassets",
		NoActorHooking = _G.PTM_MODE == "noactorhook",
	}

if PhantomModes.NoAssets then
	for key, _ in AssetMap do
		AssetMap[key] = ""
	end
end

local function GetService(serviceName)
	return cloneref(game:GetService(serviceName))
end

-- local CoreGui = GetService("CoreGui")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local HiddenInterface = gethui()
local CachedActors = (getactors or function()
	return {}
end)()

-- note: velocity v2 is ass rn
CachedActors = type(CachedActors) == "table" and CachedActors or {}

if not run_on_actor or not iscclosure(run_on_actor) then
	run_on_actor = function(_, __, ...) end

	SendNotification({ Title = "Phantom", Text = "Your executor doesnt support actor api, but the script will work!" })
end

for _, ScreenGui in HiddenInterface:GetChildren() do
	if ScreenGui:IsA("ScreenGui") and ScreenGui.Name == "Phantom" then
		ScreenGui:Destroy()
	end
end

-- note: ui initialization
local Interface = { CommandBarFocued = false }
do
	-- note: main ui
	do
		local Phantom = Instance.new("ScreenGui")
		Interface.ScreenGui = Phantom
		Phantom.DisplayOrder = -1
		local View = Instance.new("Frame")
		Interface.View = View
		local TopBar = Instance.new("Frame")
		Interface.TopBar = TopBar
		local Text = Instance.new("TextLabel")
		Interface.TopBarText = Text
		local UITextSizeConstraint = Instance.new("UITextSizeConstraint")
		local SettingsButton = PhantomModes.NoAssets and Instance.new("TextButton") or Instance.new("ImageButton")
		Interface.SettingsButton = SettingsButton
		local CommandBar = Instance.new("TextBox")
		Interface.CommandBar = CommandBar
		local UIPadding = Instance.new("UIPadding")
		local UITextSizeConstraint_2 = Instance.new("UITextSizeConstraint")
		local UIListLayout = Instance.new("UIListLayout")
		local SearchResults = Instance.new("ScrollingFrame")
		Interface.SearchResults = SearchResults
		local UIGridLayout = Instance.new("UIGridLayout")

		Phantom.Name = "Phantom"
		Phantom.Parent = HiddenInterface
		Phantom.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

		View.Name = "View"
		View.Parent = Phantom
		View.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		View.BackgroundTransparency = 1.000
		View.BorderColor3 = Color3.fromRGB(0, 0, 0)
		View.BorderSizePixel = 0
		-- {0.87, 0},{0.953, 0}
		-- View.Position = UDim2.new(0.870000005, 0, 0.768999994, 1)
		View.Position = UDim2.new(0.87, 0, 0.953, 1)
		View.Size = UDim2.new(0.129999995, 0, 0.230000004, 0)

		TopBar.Name = "TopBar"
		TopBar.Parent = View
		TopBar.BackgroundColor3 = Color3.fromRGB(36, 36, 37)
		TopBar.BorderColor3 = Color3.fromRGB(0, 0, 0)
		TopBar.BorderSizePixel = 0
		TopBar.Size = UDim2.new(1, 0, 0.100000001, 0)
		TopBar.LayoutOrder = 1

		Text.Name = "Text"
		Text.Parent = TopBar
		Text.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Text.BackgroundTransparency = 1.000
		Text.BorderColor3 = Color3.fromRGB(0, 0, 0)
		Text.BorderSizePixel = 0
		Text.Size = UDim2.new(1, 0, 1, 0)
		Text.Font = Enum.Font.SourceSans
		Text.Text = "Phantom v" .. PHANTOM_ENV.SCRIPT_VERSION .. " - " .. math.random(1000, 9999)
		Text.TextColor3 = Color3.fromRGB(236, 236, 236)
		Text.TextScaled = true
		Text.TextSize = 24.000
		Text.TextWrapped = true

		UITextSizeConstraint.Parent = Text
		UITextSizeConstraint.MaxTextSize = 23

		SettingsButton.Name = "SettingsButton"
		SettingsButton.Parent = TopBar
		SettingsButton.BackgroundColor3 = Color3.fromRGB(55, 48, 126)
		SettingsButton.BackgroundTransparency = PhantomModes.NoAssets and 0 or 1
		SettingsButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
		SettingsButton.BorderSizePixel = 0
		SettingsButton.Position = UDim2.new(1, -24, 0, 0)
		SettingsButton.Size = UDim2.new(0, 24, 0.99000001, 0)
		if not PhantomModes.NoAssets then
			SettingsButton.Image = AssetMap.SettingsButton
		else
			SettingsButton.Text = ""
		end

		CommandBar.Name = "CommandBar"
		CommandBar.Parent = View
		CommandBar.BackgroundColor3 = Color3.fromRGB(46, 46, 47)
		CommandBar.BorderColor3 = Color3.fromRGB(0, 0, 0)
		CommandBar.BorderSizePixel = 0
		CommandBar.Size = UDim2.new(1, 0, 0.100000001, 0)
		CommandBar.Font = Enum.Font.SourceSans
		CommandBar.PlaceholderText = "Command bar (;)"
		CommandBar.Text = ""
		CommandBar.TextColor3 = Color3.fromRGB(227, 227, 227)
		CommandBar.TextSize = 14.000
		CommandBar.TextXAlignment = Enum.TextXAlignment.Left
		CommandBar.LayoutOrder = 2

		UIPadding.Parent = CommandBar
		UIPadding.PaddingBottom = UDim.new(0, 4)
		UIPadding.PaddingLeft = UDim.new(0, 8)
		UIPadding.PaddingTop = UDim.new(0, 4)

		UITextSizeConstraint_2.Parent = CommandBar
		UITextSizeConstraint_2.MaxTextSize = 24
		UITextSizeConstraint_2.MinTextSize = 20

		UIListLayout.Parent = View
		UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder

		SearchResults.Name = "SearchResults"
		SearchResults.Parent = View
		SearchResults.Active = true
		SearchResults.BackgroundColor3 = Color3.fromRGB(36, 36, 36)
		SearchResults.BorderColor3 = Color3.fromRGB(0, 0, 0)
		SearchResults.BorderSizePixel = 0
		SearchResults.Size = UDim2.new(1, 0, 0.800000012, 0)
		SearchResults.BottomImage = ""
		SearchResults.CanvasSize = UDim2.new(0, 0, 0, 0)
		SearchResults.TopImage = ""
		SearchResults.LayoutOrder = 3

		UIGridLayout.Parent = SearchResults
		UIGridLayout.SortOrder = Enum.SortOrder.LayoutOrder
		UIGridLayout.CellPadding = UDim2.new(0, 0, 0, 0)
		UIGridLayout.CellSize = UDim2.new(1, 0, 0.150000006, 0)
	end

	-- note: command button template
	do
		local CommandButton = Instance.new("TextButton")
		Interface.CommandButtonTemplate = CommandButton
		local UIPadding = Instance.new("UIPadding")
		local UITextSizeConstraint = Instance.new("UITextSizeConstraint")
		CommandButton.Name = "CommandButtonTemplate"
		CommandButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		CommandButton.BackgroundTransparency = 1.000
		CommandButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
		CommandButton.BorderSizePixel = 0
		CommandButton.Size = UDim2.new(0, 200, 0, 50)
		CommandButton.Font = Enum.Font.SourceSans
		CommandButton.Text = "copyid [plr]"
		CommandButton.TextColor3 = Color3.fromRGB(231, 231, 231)
		CommandButton.TextSize = 14.000
		CommandButton.TextXAlignment = Enum.TextXAlignment.Left

		UIPadding.Parent = CommandButton
		UIPadding.PaddingBottom = UDim.new(0, 4)
		UIPadding.PaddingLeft = UDim.new(0, 8)
		UIPadding.PaddingTop = UDim.new(0, 4)

		UITextSizeConstraint.Parent = CommandButton
		UITextSizeConstraint.MaxTextSize = 24
		UITextSizeConstraint.MinTextSize = 20
	end
end

local API = {
	RegisteredCommands = {},

	PropertiesBlocked = {},
	MovementAPI = "roblox",
	TriggerBot = {
		Enabled = false,
		AutoStop = false,
		Delay = 0,
		ChangeState = false,
		TeamCheck = false,
	},
	OnRespawnCommand = "",
	LoopCommand = "",
}
if getgenv().PHANTOM_API then
	API = getgenv().PHANTOM_API
end
API.RegisteredCommands = {}
PHANTOM_ENV.API = API
getgenv().PHANTOM_API = API

do
	function API.addcmd(name, aliases, func, plugin)
		table.insert(API.RegisteredCommands, {
			Name = name,
			Aliases = aliases,
			Callback = func,
			Plugin = plugin,
		})
	end

	function API.findCmd(name)
		for _, cmd in API.RegisteredCommands do
			if cmd.Name:match(name) then
				return cmd
			end
			for _, alias in cmd.Aliases do
				if alias:match(name) then
					return cmd
				end
			end
		end
	end

	function API.execCmd(text, noNotification)
		local CommandName = text:split(" ")[1]
		if CommandName == "" then
			return
		end
		local Command = API.findCmd(CommandName)
		if not Command then
			return SendNotification({
				Title = "Phantom",
				Text = string.format('Couldnt find command "%s"', CommandName),
			})
		end
		local success, err = pcall(Command.Callback, unpack(text:split(" "), 2))
		if not success and not noNotification then
			SendNotification({ Title = string.format("Phantom, command %s failed", Command.Name), Text = err })
		end
		return success
	end

	function API.clearSearchResults()
		for _, child in Interface.SearchResults:GetChildren() do
			if child:IsA(Interface.CommandButtonTemplate.ClassName) then
				child:Destroy()
			end
		end
	end

	function API.createButton(cmd)
		local Button = Interface.CommandButtonTemplate:Clone()
		Button.Parent = Interface.SearchResults
		Button.Text = cmd.Name
		if #cmd.Aliases ~= 0 then
			Button.Text = Button.Text .. " ("
			for i, alias in cmd.Aliases do
				Button.Text = Button.Text .. alias
				if i ~= #cmd.Aliases then
					Button.Text = Button.Text .. ", "
				end
			end
			Button.Text = Button.Text .. ")"
		end
	end
end

-- note: comm channel api cuz atlantis sucks ass
-- do
-- 	local COMM_CHANNEL_PREFIX = "COMMCHANNEL_"
-- 	-- note: ima kys cuz atlantis is so fucking bad
-- 	function create_comm_channel()
-- 		local Identifier = game:GetService("HttpService"):GenerateGUID(false)
-- 		local Event = Instance.new("BindableEvent")
-- 		getgenv()[COMM_CHANNEL_PREFIX .. Identifier] = Event
-- 		return Identifier, Event
-- 	end
-- 	function get_comm_channel(id)
-- 		return getgenv()[COMM_CHANNEL_PREFIX .. id]
-- 	end
-- end

local Utils = {}
PHANTOM_ENV.Utils = Utils

do
	function Utils.SafeDisconnect(connection) end
	function Utils.GetBasicTag(instance, property)
		return (instance.ClassName .. "_" .. property):lower()
	end
	-- function Utils.GetInstanceHash(instance)
	-- 	local success, id = pcall(function()
	-- 		return instance.UniqueId
	-- 	end)
	-- 	if success then
	-- 		return id
	-- 	end
	-- 	return crypt.hash(tostring(instance))
	-- end
	-- function Utils.GetUniqueTag(instance, property)
	-- 	return (instance.UniqueId .. "_" .. property):lower()
	-- end
	local SpoofedProperties = {}
	function Utils.SafeSetProperty(instance, property, value)
		local DisabledConnections = {}
		for _, conn in getconnections(instance.Changed) do
			if conn.State or conn.Enabled then
				conn:Disable()
				table.insert(DisabledConnections, conn)
			end
		end
		for _, conn in getconnections(instance:GetPropertyChangedSignal(property)) do
			if conn.State or conn.Enabled then
				conn:Disable()
				table.insert(DisabledConnections, conn)
			end
		end
		local OrigValue = instance[property]
		instance[property] = value
		Utils.SpoofProperty(instance, property, OrigValue)
		for _, conn in DisabledConnections do
			conn:Enable()
		end
	end

	function Utils.SpoofProperty(instance, property, value)
		if not SpoofedProperties[instance] then
			SpoofedProperties[instance] = {}
		end
		SpoofedProperties[instance][property] = value
	end

	local __index
	__index = hookmetamethod(game, "__index", function(self, key)
		if not checkcaller() then
			if SpoofedProperties[self] then
				return SpoofedProperties[self][key] or __index(self, key)
			end
		end
		return __index(self, key)
	end)

	for _, actor in CachedActors do
		if PhantomModes.NoActorHooking then
			break
		end
		-- print("__index hook (spoof) for", actor, PhantomModes.NoActorHooking)
		-- run_on_actor(
		-- 	actor,
		-- 	[[
		-- 	local SpoofedProperties = ...
		-- 	if typeof(SpoofedProperties) ~= "table" then
		-- 		return error("If this error ever occurs please report it to the maintainers or try to restart the script (0x01)")
		-- 	end
		-- 	local __index
		-- 	__index = hookmetamethod(game, "__index", function(self, key)
		-- 		if not checkcaller() then
		-- 			if SpoofedProperties[self] then
		-- 				return SpoofedProperties[self][key] or __index(self, key)
		-- 			end
		-- 		end
		-- 		return __index(self, key)
		-- 	end)
		-- ]],
		-- 	SpoofedProperties
		-- )
	end

	function Utils.GetCharacter(player)
		player = player or LocalPlayer
		for _, desc in workspace:GetDescendants() do
			if desc:IsA("Model") and desc:FindFirstChild("Humanoid") and desc.Name:match(player.Name) then
				return desc
			end
		end
		if player.Character then
			return player.Character
		end
	end
	-- do
	-- 	local CachedCharacters = {}

	-- 	local old
	-- 	old = hookfunction(
	-- 		Utils.GetCharacter,
	-- 		newlclosure(function(player)
	-- 			if CachedCharacters[player] and CachedCharacters[player].Parent ~= nil then
	-- 				return CachedCharacters[player]
	-- 			end
	-- 			CachedCharacters[player] = old(player)
	-- 			return CachedCharacters[player]
	-- 		end)
	-- 	)
	-- end

	function Utils.GetProperty(instance, property)
		if SpoofedProperties[instance] and SpoofedProperties[instance][property] then
			return SpoofedProperties[instance][property]
		end
		return instance[property]
	end
end

-- note: ui lua implementation
do
	Interface.CommandBar:GetPropertyChangedSignal("Text"):Connect(function()
		API.clearSearchResults()
		local CommandName = Interface.CommandBar.Text:split(" ")[1]
		for _, cmd in API.RegisteredCommands do
			if cmd.Name:match(CommandName) then
				API.createButton(cmd)
			else
				for _, alias in cmd.Aliases do
					if alias:match(CommandName) then
						API.createButton(cmd)
						break
					end
				end
			end
		end
	end)

	local Tween = nil
	Interface.View.MouseEnter:Connect(function()
		if Tween then
			Tween:Cancel()
		end
		Tween = TweenService:Create(Interface.View, TweenInfo.new(0.4), { Position = UDim2.new(0.87, 0, 0.769, 1) })
		Tween:Play()
	end)

	Interface.View.MouseLeave:Connect(function()
		if Tween then
			Tween:Cancel()
		end
		Tween = TweenService:Create(Interface.View, TweenInfo.new(0.4), { Position = UDim2.new(0.87, 0, 0.953, 1) })
		Tween:Play()
	end)

	-- note: idk why its so unstable
	-- note: ts actually pmo
	for _, conn in getconnections(game:GetService("UserInputService").InputBegan) do
		if conn.Function then
			pcall(function(...)
				local old
				old = hookfunction(conn.Function, function(...)
					task.wait(0.1)
					if not Interface.CommandBarFocued then
						return old(...)
					end
				end)
			end)
		end
	end
	UserInputService.InputBegan:Connect(function(input, gpe)
		if gpe then
			return
		end
		if input.KeyCode == Enum.KeyCode.Semicolon then
			-- note: we add delay so the ; wont get captured
			task.wait(0)
			Interface.CommandBar:CaptureFocus()
		end
	end)

	Interface.CommandBar.Focused:Connect(function()
		Interface.CommandBarFocued = true
		if Tween then
			Tween:Cancel()
		end
		Tween = TweenService:Create(Interface.View, TweenInfo.new(0.4), { Position = UDim2.new(0.87, 0, 0.769, 1) })
		Tween:Play()
	end)
	Interface.CommandBar.FocusLost:Connect(function()
		Interface.CommandBarFocued = false
		if Tween then
			Tween:Cancel()
		end
		Tween = TweenService:Create(Interface.View, TweenInfo.new(0.4), { Position = UDim2.new(0.87, 0, 0.953, 1) })
		Tween:Play()
		if UserInputService:IsKeyDown(Enum.KeyCode.Return) then
			local Text = Interface.CommandBar.Text
			Interface.CommandBar.Text = ""
			API.execCmd(Text)
		end
	end)
end

API.addcmd("close", { "exit" }, function()
	Interface.ScreenGui:Destroy()
	if getgenv().ExunysDeveloperESP then
		getgenv().ExunysDeveloperESP.Settings.Enabled = false
	end
	SendNotification({ Title = "Phantom", Text = "Closing Phantom" })
end, nil)

API.addcmd("esp", {}, function()
	if identifyexecutor():find("Xeno") then
		return SendNotification({ Title = "Phantom", Text = "Xeno is not supported" })
	end
	if getgenv().ExunysDeveloperESP then
		return SendNotification({ Title = "Phantom", Text = "ESP already loaded!" })
	end
	SendNotification({ Title = "Phantom", Text = "Loading Esp..." })
	loadstring(game:HttpGet("https://raw.githubusercontent.com/Exunys/Exunys-ESP/main/src/ESP.lua"))()()
	-- note: this is a fixed version of exunys esp
	-- loadstring(game:HttpGet("https://pastebin.com/raw/p5drqkud"))()()
end, nil)

API.addcmd("esptoggle", {}, function()
	if not getgenv().ExunysDeveloperESP then
		API.execCmd("esp")
		-- return SendNotification({Title = "Phantom", Text = "ESP not loaded!"})
	end
	getgenv().ExunysDeveloperESP.Settings.Enabled = not getgenv().ExunysDeveloperESP.Settings.Enabled
end)

API.addcmd("espteamcheck", {}, function()
	if not getgenv().ExunysDeveloperESP then
		API.execCmd("esp")
		-- return SendNotification({Title = "Phantom", Text = "ESP not loaded!"})
	end
	getgenv().ExunysDeveloperESP.Settings.TeamCheck = not getgenv().ExunysDeveloperESP.Settings.TeamCheck
end)

API.addcmd("esptracers", {}, function()
	if not getgenv().ExunysDeveloperESP then
		API.execCmd("esp")
		-- return SendNotification({Title = "Phantom", Text = "ESP not loaded!"})
	end
	if not getgenv().ExunysDeveloperESP.Settings.Enabled then
		SendNotification({ Title = "Phantom", Text = "ESP is disabled!" })
	end
	getgenv().ExunysDeveloperESP.Properties.Tracer.Enabled = not getgenv().ExunysDeveloperESP.Properties.Tracer.Enabled
end)

API.addcmd("esphead", {}, function()
	if not getgenv().ExunysDeveloperESP then
		API.execCmd("esp")
		-- return SendNotification({Title = "Phantom", Text = "ESP not loaded!"})
	end
	if not getgenv().ExunysDeveloperESP.Settings.Enabled then
		SendNotification({ Title = "Phantom", Text = "ESP is disabled!" })
	end
	getgenv().ExunysDeveloperESP.Properties.HeadDot.Enabled =
		not getgenv().ExunysDeveloperESP.Properties.HeadDot.Enabled
end)

API.addcmd("esphealth", {}, function()
	if not getgenv().ExunysDeveloperESP then
		API.execCmd("esp")
		-- return SendNotification({Title = "Phantom", Text = "ESP not loaded!"})
	end
	if not getgenv().ExunysDeveloperESP.Settings.Enabled then
		SendNotification({ Title = "Phantom", Text = "ESP is disabled!" })
	end
	getgenv().ExunysDeveloperESP.Properties.HealthBar.Enabled =
		not getgenv().ExunysDeveloperESP.Properties.HealthBar.Enabled
end)

Players.PlayerRemoving:Connect(function(player)
	if player == LocalPlayer then
		getgenv().ExunysDeveloperESP.Settings.Enabled = false
	end
end)

API.addcmd("walkspeed", { "speed", "ws" }, function(speed)
	assert(tonumber(speed, 10), "arg ~= number")
	-- note: fix SafeSetProperty hooking error (checkcaller is stupid)
	Utils.SafeSetProperty(
		Utils.GetCharacter():FindFirstChildWhichIsA("Humanoid", true),
		"WalkSpeed",
		tonumber(speed, 10)
	)
end, nil)

API.addcmd("jumppower", { "jumpp" }, function(int)
	assert(tonumber(int, 10), "arg ~= number")
	Utils.SafeSetProperty(Utils.GetCharacter():FindFirstChildWhichIsA("Humanoid", true), "JumpPower", tonumber(int, 10))
end, nil)

API.addcmd("jumpheight", { "jumph" }, function(int)
	assert(tonumber(int, 10), "arg ~= number")
	Utils.SafeSetProperty(
		Utils.GetCharacter():FindFirstChildWhichIsA("Humanoid", true),
		"JumpHeight",
		tonumber(int, 10)
	)
end, nil)

API.addcmd("gravity", {}, function(int)
	assert(tonumber(int, 10), "arg ~= number")
	Utils.SafeSetProperty(workspace, "Gravity", tonumber(int, 10))
end, nil)

-- note: property readonly/writeable
do
	API.addcmd("propertyreadonly", {}, function(classname, property)
		table.insert(API.PropertiesBlocked, (classname .. "_" .. property):lower())
	end)

	API.addcmd("propertywriteable", {}, function(classname, property)
		table.remove(API.PropertiesBlocked, table.find(API.PropertiesBlocked, (classname .. "_" .. property):lower()))
	end)

	local __newindex
	__newindex = hookmetamethod(game, "__newindex", function(self, key, value)
		local Tag = (self.ClassName .. "_" .. key):lower()
		if table.find(API.PropertiesBlocked, Tag) and not checkcaller() then
			return
		end
		return __newindex(self, key, value)
	end)

	for _, actor in CachedActors do
		if PhantomModes.NoActorHooking then
			break
		end
		-- print("__newindex hook for", actor)
		-- run_on_actor(
		-- 	actor,
		-- 	[[
		-- 	local API = ...
		-- 	local __newindex
		-- 	__newindex = hookmetamethod(game, "__newindex", function(self, key, value)
		-- 		local Tag = (self.ClassName .. "_" .. key):lower()
		-- 		if table.find(API.PropertiesBlocked, Tag) and not checkcaller() then
		-- 			return
		-- 		end
		-- 		return __newindex(self, key, value)
		-- 	end)
		-- ]],
		-- 	API
		-- )
	end
end

-- note: noclip
do
	local NoclippingConnection
	local Enabled = false
	local DisabledCollisionParts = {}
	local ConnList = {}
	API.addcmd("noclip", {}, function()
		if not LocalPlayer.Character then
			return SendNotification({ Title = "Phantom", Text = "You must be alive" })
		end
		Enabled = true
		API.execCmd("propertyreadonly Part CanCollide")
		NoclippingConnection = game:GetService("RunService").Stepped:Connect(function()
			if LocalPlayer.Character and Enabled then
				for _, child in pairs(LocalPlayer.Character:GetDescendants()) do
					if child:IsA("BasePart") and child.CanCollide == true then
						child.CanCollide = false
						if not table.find(DisabledCollisionParts, child) then
							-- Utils.SafeSetProperty(child, "CanCollide", false)
							-- table.insert(
							-- 	ConnList,
							-- 	child:GetPropertyChangedSignal("CanCollide"):Connect(function()
							-- 		Utils.SafeSetProperty(child, "CanCollide", false)
							-- 	end)
							-- )
							table.insert(DisabledCollisionParts, child)
						end
					end
				end
			end
		end)

		SendNotification({ Title = "Phantom", Text = "Noclip enabled" })
	end)

	API.addcmd("unnoclip", {}, function()
		Enabled = false
		if NoclippingConnection then
			task.wait()
			NoclippingConnection:Disconnect()
		end
		API.execCmd("propertywriteable Part CanCollide")
		for _, conn in ConnList do
			conn:Disconnect()
		end
		table.clear(ConnList)
		for _, child in DisabledCollisionParts do
			child.CanCollide = true
			-- Utils.SafeSetProperty(child, "CanCollide", true)
		end
		table.clear(DisabledCollisionParts)
		SendNotification({ Title = "Phantom", Text = "Noclip disabled" })
	end)
end

-- note: movement api
do
	-- local CurrentWalkDirection = Vector3.zero
	-- todo: add cmd to switch movement api from roblox to custom
	-- note: client doesnt change Velocity but its updated\
	-- https://create.roblox.com/docs/reference/engine/classes/Player#Move
	API.addcmd("movementapi", { "mvapi" }, function(apiName)
		apiName = apiName:lower()
		if apiName ~= "roblox" and apiName ~= "custom" then
			error(string.format("expected roblox or custom got %s", apiName))
		end
		API.MovementAPI = apiName
	end)

	local Move
	Move = hookfunction(
		LocalPlayer.Move,
		newcclosure(function(self, walkDirection, relativeToCamera)
			if
				not self:IsA("Player")
				or typeof(walkDirection) ~= "Vector3"
				or typeof(relativeToCamera) ~= "boolean"
				or API.MovementAPI:lower() == "roblox"
			then
				return Move(self, walkDirection, relativeToCamera)
			end
			if API.MovementAPI:lower() ~= "custom" then
				API.MovementAPI = "roblox"
				error("invalid movementapi expected roblox or custom")
			end
			local Delta = RunService.Heartbeat:Wait()
			local WalkSpeed =
				Utils.GetProperty(Utils.GetCharacter():FindFirstChildWhichIsA("Humanoid", true), "WalkSpeed")

			Utils.GetCharacter().PrimaryPart.CFrame = Utils.GetCharacter().PrimaryPart.CFrame
				+ walkDirection * WalkSpeed * Delta
			-- if not relativeToCamera then
			-- 	return
			-- end
			-- note: todo replicate relativeToCamera math stuff
			-- error("TODO - implement Player.Move relativeToCamera")
		end)
	)

	-- local function CharacterAdded(char)
	-- 	char:FindFirstChild("Humanoid").Died:Once(function()
	-- 		CurrentWalkDirection = Vector3.zero
	-- 	end)
	-- end

	-- LocalPlayer.CharacterAdded:Connect(CharacterAdded)
	-- if LocalPlayer.Character then
	-- 	CharacterAdded(LocalPlayer.Character)
	-- end
end

-- note: bhop
do
	local BHOPEnabled = false
	API.addcmd("bunnyhop", { "bhop" }, function()
		BHOPEnabled = not BHOPEnabled
		SendNotification({
			Title = "Phantom",
			Text = string.format("Bhop is now %s", BHOPEnabled and "enabled" or "disabled"),
		})
	end)

	local function CharacterAdded(character)
		repeat
			task.wait()
		until character:FindFirstChild("Humanoid", true)
		local Humanoid = character:FindFirstChild("Humanoid", true)
		Humanoid.StateChanged:Connect(function(new)
			if new == Enum.HumanoidStateType.Landed then
				if BHOPEnabled and UserInputService:IsKeyDown(Enum.KeyCode.Space) then
					task.wait()
					Humanoid.Jump = true
				end
			end
		end)
	end

	LocalPlayer.CharacterAdded:Connect(CharacterAdded)
	if LocalPlayer.Character then
		task.spawn(function()
			CharacterAdded(LocalPlayer.Character)
		end)
	end
end

do
	local Mouse = LocalPlayer:GetMouse()

	API.addcmd("triggerbot", {}, function()
		API.TriggerBot.Enabled = not API.TriggerBot.Enabled
		SendNotification({
			Title = "Phantom",
			Text = string.format("Trigger bot is now %s", API.TriggerBot.Enabled and "Enabled" or "Disabled"),
		})
	end)

	API.addcmd("triggerbotdelay", { "tbdelay" }, function(intstr)
		local Value = tonumber(intstr, 10)
		if not Value then
			return SendNotification({ Title = "Phantom", Text = "triggerbotdelay expects a number" })
		end
		API.TriggerBot.Delay = Value
	end)

	API.addcmd("triggerbotautostop", { "tbautostop" }, function()
		API.TriggerBot.AutoStop = not API.TriggerBot.AutoStop
		SendNotification({
			Title = "Phantom",
			Text = string.format("Auto stop is now %s", API.TriggerBot.AutoStop and "Enabled" or "Disabled"),
		})
	end)

	API.addcmd("triggerbotchangestate", { "tbchangestate" }, function()
		API.TriggerBot.ChangeState = not API.TriggerBot.ChangeState
		SendNotification({
			Title = "Phantom",
			Text = string.format("ChangeState is now %s", API.TriggerBot.ChangeState and "Enabled" or "Disabled"),
		})
	end)

	API.addcmd("triggerbotteamcheck", { "tbteamcheck" }, function()
		API.TriggerBot.TeamCheck = not API.TriggerBot.TeamCheck
		SendNotification({
			Title = "Phantom",
			Text = string.format("TeamCheck is now %s", API.TriggerBot.TeamCheck and "Enabled" or "Disabled"),
		})
	end)

	task.spawn(function()
		while true do
			RunService.Heartbeat:Wait()
			if not API.TriggerBot.Enabled then
				continue
			end
			pcall(function()
				if Mouse.Target then
					local Character = Mouse.Target.Parent
					local TargetPlayer = Players:GetPlayerFromCharacter(Character)
					local TargetHumanoid = Character:FindFirstChildWhichIsA("Humanoid", true)
					if
						Character:IsA("Model")
						and TargetHumanoid
						and Utils.GetCharacter()
						and TargetPlayer ~= LocalPlayer
					then
						if TargetPlayer then
							if TargetPlayer.Team == LocalPlayer.Team and API.TriggerBot.TeamCheck then
								return
							end
						end
						if TargetHumanoid.Health < 0 then
							return
						end
						local OrigVelocity
						local OrigState
						local PrimaryPart = Utils.GetCharacter().PrimaryPart
						if not PrimaryPart then
							return
						end
						local Humanoid = Utils.GetCharacter():FindFirstChildWhichIsA("Humanoid", true)
						if not Humanoid or Humanoid.Health < 0 then
							return
						end
						if API.TriggerBot.AutoStop then
							OrigVelocity = PrimaryPart.Velocity
							PrimaryPart.Velocity = Vector3.zero
							-- note: counter blox fix
							if game.PlaceId == 301549746 then
								RunService.Heartbeat:Wait()
							end
						end
						if API.TriggerBot.ChangeState then
							OrigState = Humanoid:GetState()
							Humanoid:ChangeState(Enum.HumanoidStateType.Landed)
						end
						if API.TriggerBot.Delay >= 0 then
							task.wait(API.TriggerBot.Delay)
						end
						mouse1press()
						RunService.Heartbeat:Wait()
						-- note: counter blox fix
						if game.PlaceId == 301549746 then
							RunService.Heartbeat:Wait()
						end
						if OrigVelocity then
							PrimaryPart.Velocity = OrigVelocity
						end
						if OrigState then
							Humanoid:ChangeState(OrigState)
						end
						mouse1release()
					end
				end
			end)
		end
	end)
end

-- note: spinbot
do
end

-- note: rejoin on kick /autorejoin

-- note: on character spawn
do
	API.addcmd("onrespawn", { "oncharacteradded" }, function(...)
		API.OnRespawnCommand = table.concat({ ... }, " ")
	end)

	LocalPlayer.CharacterAdded:Connect(function()
		if API.OnRespawnCommand ~= "" then
			SendNotification({ Title = "Phantom - On respawn", Text = "Executing command " .. API.OnRespawnCommand })
			task.wait(0.2)
			API.execCmd(API.OnRespawnCommand)
		end
	end)
end

do
	API.addcmd("loop", { "heartbeat" }, function(...)
		API.LoopCommand = table.concat({ ... }, " ")
	end)

	RunService.Heartbeat:Connect(function()
		if API.LoopCommand ~= "" then
			local success = API.execCmd(API.LoopCommand, true)
			if not success then
				API.LoopCommand = ""
			end
		end
	end)
end
